# cli_md_renderer.py
from __future__ import annotations

import argparse

# Your parser source
from flet_cli.cli import get_parser


def render_cli_markdown(
    command_path: str = "",
    *,
    heading_level: int = 2,  # Section titles only (no top command title)
    include_help_version: bool = False,
    list_subcommands_only: bool = True,
    program_name: str | None = None,
) -> str:
    """Render Markdown for exactly one argparse command/subcommand.

    This is a single-function, drop-in renderer designed for MkDocs pages.

    Behavior
    --------
    - No top-level command title is printed (your page already has it).
    - Description paragraph comes first (dedented, capitalized, period-added).
    - `Usage` uses `program_name` (e.g., "flet") instead of the local script.
    - Positional arguments are **titled sections** (not bulleted), required-first.
    - Options use **Style 1** (compact headings): canonical long flag as the title;
      shows Value only when informative; shows Default when meaningful; shows
      **Required:** true only if `required=True`; shows **Aliases:** excluding the title flag.
    - Choices are shown inline as: **Possible values:** `a`, `b`, `c`
      (not bulleted, and consistent with the Aliases line).

    Args:
        command_path: Space-separated subcommand chain. Examples: "", "create", "build ios".
        heading_level: Base markdown heading level for sections (default 2 -> "##").
        include_help_version: Include autogenerated -h/--help and --version/-V options.
        list_subcommands_only: If True and the command has subcommands, list them briefly.
        program_name: Override the root program name shown in Usage (e.g., "flet").

    Returns:
        A markdown string for the selected command/subcommand.
    """
    # --- single-function, self-contained ---
    import argparse
    import textwrap

    # ---------------- helpers ----------------
    def _is_suppress(v: object) -> bool:
        """Return True if argparse suppress sentinel is used."""
        return v is argparse.SUPPRESS or v == "==SUPPRESS=="

    def _takes_value(a: argparse.Action) -> bool:
        """Return True if this action consumes a value (not boolean/count/help/version)."""
        return not isinstance(
            a,
            (
                argparse._StoreTrueAction,
                argparse._StoreFalseAction,
                argparse._CountAction,
                argparse._HelpAction,
                argparse._VersionAction,
            ),
        )

    def _all_flags(a: argparse.Action) -> list[str]:
        """All switches for an option, short first then long (for Aliases display)."""
        shorts = [
            s for s in a.option_strings if s.startswith("-") and not s.startswith("--")
        ]
        longs = [s for s in a.option_strings if s.startswith("--")]
        return shorts + longs if (shorts or longs) else list(a.option_strings)

    def _canonical_heading_flag(a: argparse.Action) -> str:
        """Pick the canonical flag for the option heading (prefer long; else short; else dest)."""
        longs = [s for s in a.option_strings if s.startswith("--")]
        if longs:
            return longs[0]
        shorts = [
            s for s in a.option_strings if s.startswith("-") and not s.startswith("--")
        ]
        if shorts:
            return shorts[0]
        return a.option_strings[0] if a.option_strings else a.dest

    def _clean(s: str | None) -> str | None:
        """Dedent and trim leading/trailing whitespace safely."""
        return textwrap.dedent(s).strip() if s else s

    def _cap_first(s: str | None) -> str | None:
        """Capitalize first letter and ensure trailing period; do not change grammar."""
        if not s:
            return s
        t = s.strip()
        if not t:
            return t
        t = t[0].upper() + t[1:]
        if t[-1] not in ".!?":
            t += "."
        return t

    def _head(level: int, text: str) -> str:
        """Markdown heading helper (#... text)."""
        return f"{'#' * level} {text}"

    def _ensure_blank(lines: list[str]) -> None:
        """Append a blank line if last line is not blank."""
        if lines and lines[-1] != "":
            lines.append("")

    def _format_default(a: argparse.Action) -> str | None:
        """Return formatted default if meaningful, else None."""
        if _is_suppress(a.default):
            return None
        # Booleans: only show if True (False is the common default).
        if isinstance(a, (argparse._StoreTrueAction, argparse._StoreFalseAction)):
            return f"`{bool(a.default)}`" if bool(a.default) else None
        # -v count: hide when 0
        if isinstance(a, argparse._CountAction):
            return f"`{a.default}`" if a.default not in (None, 0) else None
        # Default equal to const is not helpful
        if getattr(a, "const", None) is not None and a.default == a.const:
            return None
        if a.default not in (None, ""):
            return f"`{a.default}`"
        return None

    def _metavar_if_informative(a: argparse.Action, *, positional: bool) -> str | None:
        """Return an informative metavar string or None to suppress redundant ones.

        Rules:
          - If the option doesn't take a value, return None.
          - If `choices` exist, return None (we'll render "Possible values" instead).
          - If the token is just DEST in upper-case and there is no extra info (type/nargs),
            return None (e.g., TEMPLATE_REF).
          - Otherwise include token and optional type/nargs adornments.
        """
        if not positional and not _takes_value(a):
            return None
        if a.choices:
            return None  # handled separately

        base = a.metavar or (a.dest.upper().replace("-", "_"))
        dest_upper = (a.dest or "").upper().replace("-", "_")

        # Detect meaningful nargs
        nargs_suffix = ""
        if a.nargs in ("*", "+"):
            nargs_suffix = a.nargs
        elif isinstance(a.nargs, int) and a.nargs > 1:
            nargs_suffix = f"×{a.nargs}"

        # Detect meaningful type
        t = getattr(a, "type", None)
        tname = getattr(t, "__name__", "") if callable(t) else ""
        has_type = bool(tname and tname != "str")

        informative = (nargs_suffix != "") or has_type
        if not informative and base == dest_upper:
            return None

        token = base + nargs_suffix
        if has_type:
            token += f" <{tname}>"
        return token

    def _choices_inline(a: argparse.Action) -> str | None:
        """Return inline choices like: `a`, `b`, `c` or None if no choices."""
        if not a.choices:
            return None
        items = [f"`{c}`" for c in a.choices]
        return ", ".join(items)

    def _is_help_or_version(a: argparse.Action) -> bool:
        """True if this is the auto-generated -h/--help or --version/-V action."""
        return isinstance(a, (argparse._HelpAction, argparse._VersionAction))

    # ---------------- resolve command ----------------
    root = get_parser()
    raw_prog = getattr(root, "prog", None) or "cli"

    # Program name shown in Usage
    if program_name:
        root_name = program_name
    else:
        # Strip trailing ".py" if present
        root_name = raw_prog.rsplit("/", 1)[-1]
        if root_name.endswith(".py"):
            root_name = root_name[:-3]

    def _resolve(
        p: argparse.ArgumentParser, parts: list[str]
    ) -> argparse.ArgumentParser:
        """Walk subcommands like ["build", "ios"] and return that subparser."""
        if not parts:
            return p
        cur = p
        used: list[str] = []
        for tok in parts:
            used.append(tok)
            subparsers = next(
                (
                    act
                    for act in cur._actions
                    if isinstance(act, argparse._SubParsersAction)
                ),
                None,
            )
            if not subparsers:
                raise ValueError(
                    f"No subcommands under: {' '.join(used[:-1]) or '(root)'}"
                )
            if tok not in subparsers.choices:
                opts = ", ".join(sorted(subparsers.choices.keys()))
                raise ValueError(f"Unknown subcommand '{tok}'. Available: {opts}")
            cur = subparsers.choices[tok]
        return cur

    parts = [p for p in command_path.split() if p]
    parser = _resolve(root, parts)

    # ---------------- build markdown ----------------
    out: list[str] = []
    section_level = heading_level  # e.g., default 2 -> "##"
    entry_level = heading_level + 1  # e.g., default 3 -> "###"

    # 1) Description paragraph first
    desc = _cap_first(_clean(parser.description))
    if desc:
        out.append(desc)
        out.append("")

    # 2) Usage (replace program name to reflect desired program_name)
    usage = parser.format_usage().strip()
    if usage.lower().startswith("usage:"):
        usage = usage[6:].strip()
    usage = usage.replace(raw_prog, root_name, 1)
    out.append(_head(section_level, "Usage"))
    out.append("")
    out.append("```bash")
    out.append(usage)
    out.append("```")

    # 3) Split actions: collect positionals, options, and subparsers action if any
    positionals_indexed: list[tuple[int, argparse.Action]] = []
    options: list[argparse.Action] = []
    subparsers = None
    for idx, act in enumerate(parser._actions):
        if isinstance(act, argparse._SubParsersAction):
            subparsers = act
        elif act.option_strings:
            options.append(act)
        else:
            positionals_indexed.append((idx, act))

    # 4) Positional arguments — titled entries, required first (stable within groups)
    if positionals_indexed:
        positionals_indexed.sort(key=lambda ia: (0 if ia[1].required else 1, ia[0]))

        out.append("")
        out.append(_head(section_level, "Positional arguments"))
        out.append("")
        for _, a in positionals_indexed:
            title = f"`{a.metavar or a.dest}`"
            out.append(_head(entry_level, title))

            body_lines: list[str] = []
            help_text = _cap_first(_clean(a.help)) or ""
            if help_text:
                body_lines.append(help_text)

            # Choices -> inline "Possible values"
            if a.choices:
                _ensure_blank(body_lines)
                body_lines.append(f"**Possible values:** {_choices_inline(a)}")
            else:
                # Metavar only when it adds information beyond plain DEST upper
                meta = _metavar_if_informative(a, positional=True)
                if meta:
                    _ensure_blank(body_lines)
                    body_lines.append(f"**Value:** `{meta}`")

            default = _format_default(a)
            if default:
                _ensure_blank(body_lines)
                body_lines.append(f"**Default:** {default}")
            else:
                # No default -> show Required true/false for positionals (explicit)
                _ensure_blank(body_lines)
                body_lines.append(f"**Required:** {'true' if a.required else 'false'}")

            if body_lines:
                out.extend(body_lines)
            out.append("")

    # 5) Options — compact headings with canonical main flag; aliases excluding title flag
    if options:
        out.append("")
        out.append(_head(section_level, "Options"))
        out.append("")

        # Sort options by long flag first for stable ordering
        def _sort(a: argparse.Action) -> str:
            longs = sorted([s for s in a.option_strings if s.startswith("--")]) or [
                "~" + (sorted(a.option_strings)[0] if a.option_strings else "")
            ]
            return longs[0]

        options = sorted(options, key=_sort)

        for a in options:
            if not include_help_version and _is_help_or_version(a):
                continue

            title_flag = _canonical_heading_flag(a)
            out.append(_head(entry_level, f"`{title_flag}`"))

            body_lines: list[str] = []
            help_text = _cap_first(_clean(a.help)) or ""
            if help_text:
                body_lines.append(help_text)

            # Choices -> inline "Possible values"
            if a.choices:
                _ensure_blank(body_lines)
                body_lines.append(f"**Possible values:** {_choices_inline(a)}")
            else:
                # Metavar only when informative
                meta = _metavar_if_informative(a, positional=False)
                if meta:
                    _ensure_blank(body_lines)
                    body_lines.append(f"**Value:** `{meta}`")

            default = _format_default(a)
            if default:
                _ensure_blank(body_lines)
                body_lines.append(f"**Default:** {default}")

            # Only show "Required: true" for options when explicitly required.
            if getattr(a, "required", False):
                _ensure_blank(body_lines)
                body_lines.append("**Required:** true")

            # Aliases: all flags except the one shown in the heading
            aliases = [f for f in _all_flags(a) if f != title_flag]
            if aliases:
                _ensure_blank(body_lines)
                body_lines.append(
                    "**Aliases:** " + ", ".join(f"`{f}`" for f in aliases)
                )

            if body_lines:
                out.extend(body_lines)
            out.append("")

    # 6) Subcommands (list only)
    if list_subcommands_only and subparsers and subparsers.choices:
        out.append("")
        out.append(_head(section_level, "Subcommands"))
        out.append("")
        for name, sub in sorted(subparsers.choices.items()):
            d = _clean(sub.description) or ""
            first = _cap_first(d.splitlines()[0]) if d else ""
            out.append(f"- `{name}`: {first}")

    return "\n".join(out)


# Example usage while testing locally
if __name__ == "__main__":
    # Render just the 'create' subcommand and force the header to 'flet'
    page_md = render_cli_markdown("create", program_name="flet")
    print(page_md)
